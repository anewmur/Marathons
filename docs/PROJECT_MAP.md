## Цель проекта
Построить статистическую модель для предсказания времени финиша по:
- трассе (идентификатор трассы хранится в колонке race_id)
- полу
- возрасту

Работа ведётся на шкале логарифма времени:
- Y = ln(T), где T — time_seconds

Возраст учитывается через сглаженную функцию (сплайн), общую для всех трасс внутри пола.

---

## Терминология и обозначения

- race_id: строковый идентификатор трассы в данных (колонка DataFrame)
- c: трасса как математический индекс, соответствующий значениям race_id
- year: год старта (колонка); в формулах обозначается j
- gender: пол (колонка); в формулах обозначается g
- age: возраст (колонка); в формулах обозначается a

В коде и таблицах используем race_id. В формулах используем c, но понимаем, что c ⇔ race_id.

---

## Модель (математически)

Для старта i на трассе c, пола g, года j и возраста a:

Y_i = ln(T_i)

Z_i = Y_i − ln R^{use}_{c,g}(j)

Z_i = h_g(a_i) + ε_i  
ε_i ~ N(0, σ_g^2)

Где:
- R^{use}_{c,g}(j) — трассово-годовой эталон на ln-шкале
- h_g(a) — возрастная поправка (сплайн), общая по всем трассам данного пола
- σ_g^2 — дисперсия остатка

Прогноз:
- Y_pred = ln R^{use}_{c,g}(j*) + h_g(a_new)
- T_pred = exp(Y_pred)
- интервалы и неопределённость строятся на Y-шкале, затем переводятся в секунды

---

## Поток данных

### 1. Загрузка данных (DataLoader)
- читает Excel
- приводит к единому контракту
- кэширует parquet

Выход:
- df_raw

---

### 2. Базовая фильтрация и валидация сырья
- filter_raw
- validate_raw
- add_row_id

Выход:
- df_raw_valid с индексом row_id

---

## 3. Предобработка (Preprocessor)

Цель: получить df_clean, где каждая строка — корректный старт, а идентификация людей детерминирована и воспроизводима.

### 3.1 Нормализация строк
- surname, name: trim, схлопывание пробелов, пустые → NA (недопустимы),
  транслитерация кириллицы в латиницу по PERSON_TOKEN_CYR_TO_LAT,
  затем upper
- Сейчас для формально trim=0
- city: нормализация (канонизация)

### 3.2 Базовая идентификация человека по имени
- person_ordered_key = SURNAME|NAME
- person_set_key = min(SURNAME|NAME, NAME|SURNAME)
  (инвариант к перестановке имени и фамилии)

### 3.3 Приближённый год рождения
- approx_birth_year = year − age

### 3.4 Стабилизация года рождения
Внутри каждого person_set_key:
- строятся частоты approx_birth_year
- годы разбиваются на кластеры с шагом ≤ 1 год (цепочкой)
- для каждого кластера выбирается birth_year_stable
- строкам примерживается:
  - cluster_id
  - birth_year_stable

### 3.5 Формирование runner_id (контракт)
runner_id — строковый идентификатор гипотезы “один физический человек”.
На базовом шаге runner_id строится из person_set_key и стабилизированного года рождения.

Формат:
- birth_suffix = "_UNKNOWN", если отсутствуют birth_year_stable или birth_cluster_min_year
- иначе birth_suffix = f"_{birth_year_stable}_M{birth_cluster_min_year}"
- runner_id = f"{person_set_key}{birth_suffix}"

Этот формат является частью контракта и используется во всех последующих шагах.


### 3.6 Разрешение конфликтов города (политика проекта)

Город используется как жёсткий дискриминатор после стабилизации года рождения.
В базовый runner_id город не входит.

Шаги:
- если внутри runner_id город однозначен → заполняем пропуски этим значением
- если внутри runner_id город конфликтует (>=2 разных city) и city не NA → разукрупняем runner_id:
  runner_id = runner_id + "__CITY_" + city
- если внутри runner_id city == NA во всех строках → runner_id оставляем как есть
  (разделять по городу невозможно)

Интерпретация:
- разные города внутри одного runner_id считаются разными людьми,
  если это не противоречит уже выполненной стабилизации года рождения

Контракт после шага:
- внутри runner_id город либо однозначен, либо NA (если везде NA)
- разукрупнение по городу отражается в runner_id суффиксом "__CITY_{city}"

### 3.7 Исправление пола (контракт для модели)
Цель: обеспечить однозначность пола внутри runner_id.

Шаги:
- если внутри runner_id есть строгое большинство по gender → присваиваем этот gender всем строкам runner_id
- если строгого большинства нет → runner_id целиком удаляется

Контракт после шага:
- в df_clean внутри runner_id пол однозначен

### 3.8 Удаление неразрешимых конфликтов “один старт”
Ситуация:
- у одного runner_id более одной строки в одном и том же (race_id, year)

Политика:
- после шага разукрупнения runner_id по городу любые оставшиеся случаи,
  где в (runner_id, race_id, year) больше одной строки, удаляются целиком
  (редкие случаи, не стоящие отдельной логики)
- отдельный частный случай: если в (runner_id, race_id, year) > 1 строк,
  bib_number имеет > 1 уникального значения, а city однозначен, группа удаляется
  (это считается неразрешимым шумом)

### 3.9 Строгая дедупликация
Удаляются точные дубликаты по ключу:
- базовый ключ: (runner_id, race_id, year, time_seconds)
- если доля заполнения bib_number > 0.5, то bib_number добавляется в ключ:
  (runner_id, race_id, year, time_seconds, bib_number)

### 3.10 Добавление модельных признаков
- age_clamped = clip(age, age_min_global, age_max_global)
- Y = ln(time_seconds)
- x = (age_clamped − age_center) / age_scale

Выход:
- df_clean — финальный датасет для моделирования

---

## 4. Трассово-годовые эталоны R^{use}

### ReferenceBuilder

ReferenceBuilder (TraceReferenceBuilder) строит эталон на шкале времени T (секунды).
Логарифм эталона используется в формулах как ln R^{use} и вычисляется после построения эталона.

Протокол для каждой группы (race_id, gender) на входных данных build():
1) фильтруем time_seconds: не NA и > 0
2) сортируем time_seconds по возрастанию (быстрые впереди)
3) выбираем top_fraction лучших; если top_fraction даёт меньше min_used_runners наблюдений,
   то используем top_size = min(n_total, max(ceil(n_total * top_fraction), min_used_runners))
4) внутри top применяем симметричный trim_fraction
5) эталон reference_time = median(использованных time_seconds)
6) вычисляем reference_log = ln(reference_time)
7) дисперсию эталона оцениваем bootstrap по тому же протоколу

Индексация:
- в текущей реализации эталон строится по (race_id, gender) и агрегирует все годы,
  которые поданы на вход build()
- LOY vs production обеспечивается внешней фильтрацией по year до вызова build()

Выход:
- таблица эталонов reference_time и reference_log для (race_id, gender)
---

## 5. Возрастная модель (ключевая часть)

### fit_age_model

Вход:
- df_clean
- исключён validation_year (если задан)
- status == OK

Подготовка:
- возраст уже приведён к age_clamped в предобработке и именно он используется в x
- вычисляем Z = Y − ln R^{use}_{c,g}(j) для каждой строки

Оценка:
- отдельно по каждому полу g
- оцениваем h_g(a) как сглаженную функцию (сплайн)
- оцениваем σ_g^2

Выход:
- параметры сплайна h_g
- оценка σ_g^2

---

## 6. Прогноз

Вход:
- race_id (⇔ c)
- gender (g)
- age (a)
- year (j*)

Шаги:
1) берём ln R^{use}_{c,g} для пары (race_id, gender) из таблицы эталонов
   (годовая зависимость эталона в текущей реализации не используется)
2) вычисляем h_g(a)
3) Y_pred = ln R^{use} + h_g(a)
4) переводим в секунды: T_pred = exp(Y_pred)
5) интервалы: считаем на Y-шкале с учётом σ_g^2, затем exp(·)

---

## 7. Валидация

На validation_year:
- ошибки на Y-шкале и на шкале секунд
- анализ по трассам и полу
- проверка покрытия интервалов (если интервалы реализованы)

---

## Что уже реализовано

- полный пайплайн предобработки до df_clean
- person_set_key, approx_birth_year
- кластеризация годов рождения внутри person_set_key и birth_year_stable
- runner_id в фиксированном формате
- нормализация/заполнение города и разбиение runner_id по конфликтному city
- исправление пола по большинству (или удаление при отсутствии большинства) [если добавлено в код]
- удаление неразрешимых мульти-стартов (один runner_id, один race_id, один year, >1 строк)
- построение трассовых эталонов
- инфраструктура/каркас fit_age_model с диагностикой

---

## Что осталось реализовать

1) Реальная оценка сплайна h_g(a)
2) Хранение параметров сплайна и применение на новых данных
3) Прогноз с неопределённостью (интервалы)
4) Блок валидации (метрики, отчёты)
5) Финальные дампы/отчёты для контроля качества данных и модели

---

## Принципиальные позиции проекта

- идентификация людей: только детерминированные правила, без “умных” кластеризаций
- возраст: только гладкая функция (сплайн), а не дискретные “возрастные эталоны”
- допускается удаление строк и целых runner_id при неразрешимых конфликтах
  (это сознательная политика качества данных, а не “ошибка пайплайна”)
