# Отчёт о проекте MarathonModel  
**Статус:** MVP в активной разработке  
**Версия:** после реализации reference builders и системы кэширования  

---

## 1. Цель проекта

Создать систему прогнозирования времени финиша марафонцев с использованием исторических данных.

**Выход модели:**
- Медиана прогнозируемого времени  
- Квантили неопределённости (5% и 95%)

---

## 2. Архитектура проекта

```
marathon_model/
├── CODE_RULES.md
├── REPORT.md                    # этот документ
├── config.yaml                  # параметры препроцессинга и модели
├── main.py                      # [ГОТОВ] управляющий класс MarathonModel
├── data_loader.py               # [ГОТОВ] загрузка с кэшированием
├── utils.py                     # [ГОТОВ] функции парсинга
├── dictionaries.py              # [ГОТОВ] словари нормализации
├── logging_setup.py             # [ГОТОВ] настройка логирования
├── preprocessor.py              # [ГОТОВ] полный препроцессинг
├── reference_builder.py         # [ГОТОВ] TraceReferenceBuilder
├── age_reference_builder.py     # [ГОТОВ] AgeReferenceBuilder
├── age_model.py                 # [TODO] возрастная модель
├── predictor.py                 # [TODO] прогнозирование
└── visualizer.py                # [TODO] визуализация
```

---

## 3. Пайплайн данных

```
Excel-файлы → DataLoader (с кэшем) → df
                ↓
          Preprocessor → df_clean
                ↓
          TraceReferenceBuilder → эталоны трасс R_{c,g}
                ↓
          AgeReferenceBuilder → базовые медианы по возрасту
                ↓
          AgeModel → возрастная поправка h_g(age)
                ↓
          Predictor → медиана, q05, q95
```

---

## 4. Реализованные компоненты

### 4.1 DataLoader — ГОТОВ

**Основные функции:**
- Загрузка всех `*.xls` / `*.xlsx` из директории
- Извлечение метаданных (трасса + год)
- Нормализация названий трасс через `KNOWN_RACES`
- Парсинг полей: `runner_id`, `gender`, `age`, `status`, `time_seconds`, `city`, `bib_number`
- **Автоматическое кэширование с проверкой изменений**

**Система кэширования:**
- Создаёт манифест файлов: `list_excel.yaml` (имя, размер, mtime)
- Сохраняет данные в `data_cache.pkl` (формат pickle)
- При повторной загрузке сравнивает манифесты
- Если файлы не изменились → загрузка из кэша (в разы быстрее)
- Если файлы изменились → полная перезагрузка + обновление кэша

**Результат:** корректный, единообразный DataFrame с кэшированием.

---

### 4.2 Preprocessor — ГОТОВ

Включает полный устойчивый конвейер:

#### 1. Проверка данных
- Проверка наличия обязательных колонок
- Приведение типов
- Добавление `city` / `bib_number` если отсутствуют

#### 2. Фильтрация
- Оставляются только записи со статусом `"OK"`

#### 3. Разукрупнение людей (кластеризация)
Ключ группы: `(surname, name, gender)`

Алгоритм:
- Вычисляется `approx_birth_year = year - age`
- Допуск на один год (±1)
- Рекурсивное разбиение на кластеры, пока диапазон > 1
- Каждый кластер = отдельный человек

Присвоение идентификаторов:
```
Иванов_Сергей
Иванов_Сергей_1
Иванов_Сергей_2
…
```

#### 4. Нормализация и заполнение городов внутри кластера

Трёхуровневая система словарей:
1. **CLUSTER_CITY_CANONICAL_MAP** — исправление опечаток на уровне DataLoader
2. **REGION_NORMALIZATION_MAP** — унификация областей:
   - Тула → Тульская Обл.
   - Екатеринбург → Свердловская Обл.
   - Чупа → Респ. Карелия
   - Йошкар-Ола / Татарстан → Казань

Если сводится к одному канону — заполняются пропуски.  
Если остаётся >1 канонического города — кластер неоднозначен, логируется.

#### 5. Добавление признаков
```python
Y = ln(time_seconds)
x = (age - age_center) / age_scale
```
Параметры из `config.yaml`

#### 6. Дедупликация
- Удаляются только строгие дубли
- Подозрительные группы логируются, но не удаляются (для дальнейшего анализа)

---

### 4.3 TraceReferenceBuilder — ГОТОВ

**Построение эталонов трасс** `R_{c,g}` по парам `(race_id, gender)`.

**Протокол:**
1. Берём `top_fraction` самых быстрых (по умолчанию 25%)
2. Триммируем `trim_fraction` с каждого края внутри top (по умолчанию 10%)
3. Берём `median` оставшихся (в секундах)
4. Считаем `bootstrap-дисперсию` медианы

**Выходные данные:**
```
race_id, gender, 
reference_time, reference_log, reference_var,
n_total, n_used
```

**LOY-валидация:** год исключения задаётся снаружи фильтрацией DataFrame.

---

### 4.4 AgeReferenceBuilder — ГОТОВ

**Построение базовых медиан по возрасту** для пар `(gender, age)`.

**Протокол:**
1. Группировка по `(gender, age)`
2. Расчёт медианы времени в секундах
3. Расчёт `bootstrap-дисперсии` медианы

**Выходные данные:**
```
gender, age,
age_median_time, age_median_log, age_median_var,
n_total
```

**Назначение:** базовые эталоны для возрастной модели, независимые от трасс.

---

## 5. Последние изменения

### Система кэширования в DataLoader
- Реализован механизм автоматического кэширования загруженных данных
- Использование манифест-файлов для отслеживания изменений Excel-файлов
- Формат кэша: pickle (встроен в pandas, не требует дополнительных библиотек)
- Значительное ускорение повторных загрузок (особенно на больших датасетах)

### Reference Builders
- Полностью реализованы `TraceReferenceBuilder` и `AgeReferenceBuilder`
- Bootstrap-оценка дисперсии эталонов
- Валидация параметров конфигурации
- Подробное логирование пропущенных групп

### Инфраструктура
- Расширена конфигурация `config.yaml` (параметры для references и age_references)
- Улучшено логирование (цветной вывод в консоль + файл)
- Добавлены unit-тесты для reference builders

---

## 6. Дорожная карта (TODO)

### Ближайшие задачи
- [ ] Реализация `age_model.py`  
  Построение возрастной функции `h_g(age)`, сглаживание B-сплайнами с REML
- [ ] Реализация `predictor.py`  
  Сборка модели: эталон + возраст + шум → медиана, q05, q95
- [ ] Интеграция Monte Carlo для квантилей неопределённости

### Среднесрочные задачи
- [ ] Индивидуальный эффект `runner_id` в модели  
- [ ] Исключение подозрительных групп из индивидуальных блоков модели  
- [ ] Автоматическое расширение `KNOWN_RACES` (ML-распознавание трасс)
- [ ] Улучшенная маппинг-система городов (внешние источники)  
- [ ] Визуализация результатов (`visualizer.py`)

---

## 7. Пример запуска

```python
from logging_setup import easy_logging
from MarathonAgeModel import MarathonModel

# Включить логирование
easy_logging(True)

# Создать модель
model = MarathonModel(
    data_path="data/",
    validation_year=2025,
    verbose=True
)

# Выполнить пайплайн
model.run()

# Просмотр результатов
print(model.summary())
print(model.references.head())
print(model.age_references.head())
```

**С использованием кэша:**
```python
# При первом запуске — загрузка Excel + создание кэша
model.load_data()  # создаёт list_excel.yaml и data_cache.pkl

# При повторных запусках — мгновенная загрузка из кэша
# (если Excel-файлы не изменились)
model.load_data()  # загружает из data_cache.pkl
```

---

## 8. Статистика тестовых данных

**Последний прогон:**
- 3 Excel-файла
- 2063 записи
- 1772 финишировавших (`status='OK'`)
- Уникальных участников: ~800
- Нормализованные трассы:
  - Дорога жизни
  - Пермский марафон
  - Казанский марафон
  - Белые ночи

**Построенные эталоны:**
- TraceReferences: ~8-10 эталонов (по парам race_id × gender)
- AgeReferences: ~40-60 базовых медиан (по парам gender × age)

---

## 9. Технические детали

### Форматы данных
- **Входные данные:** Excel (`.xls`, `.xlsx`)
- **Кэш:** pickle (`.pkl`) — встроенный формат pandas
- **Манифест:** YAML (`.yaml`) или JSON (`.json`)
- **Конфигурация:** YAML (`.yaml`)

### Зависимости
- `pandas` — обработка данных
- `numpy` — численные вычисления
- `pyyaml` — чтение конфигурации
- `openpyxl` / `xlrd` — чтение Excel-файлов
- *Опционально:* `pyarrow` — для формата parquet (если нужна альтернатива pickle)

### Логирование
- Уровни: DEBUG, INFO, WARNING, ERROR, CRITICAL
- Вывод: консоль (цветной, без INFO) + файл `logs/last_run.log` (всё)
- Настройка: `logging_setup.easy_logging(True)`

---

## 10. Текущий итог

Пайплайн **корректно загружает с кэшированием**, **нормализует**, **кластеризует людей**, **разрешает типичные ошибки городов**, **строит эталоны трасс и возрастные базовые медианы**, **логирует проблемные случаи**.

**Следующий шаг:** AgeModel — построение возрастной функции `h_g(age)` с использованием B-сплайнов и REML.

---

## 11. Контакты и документация

- **CODE_RULES.md** — правила разработки кода
- **config.yaml** — настройка параметров модели
- **logs/last_run.log** — подробные логи последнего запуска

**Принцип разработки:** согласование → реализация → обновление документации
