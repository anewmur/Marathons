## Цель проекта
Построить статистическую модель для предсказания времени финиша по:
- трассе (идентификатор трассы хранится в колонке race_id)
- полу
- возрасту

Работа ведётся на шкале логарифма времени:
- Y = ln(T), где T — time_seconds

Возраст учитывается через сглаженную функцию (сплайн), общую для всех трасс внутри пола.

---

## Терминология и обозначения

- race_id: строковый идентификатор трассы в данных (колонка DataFrame)
- c: трасса как математический индекс, соответствующий значениям race_id
- year: год старта (колонка); в формулах обозначается j
- gender: пол (колонка); в формулах обозначается g
- age: возраст (колонка); в формулах обозначается a

В коде и таблицах используем race_id. В формулах используем c, но понимаем, что c ⇔ race_id.

---

## Модель (математически)

Для старта i на трассе c, пола g, года j и возраста a:

Y_i = ln(T_i)

Z_i = Y_i − ln R^{use}_{c,g}(j)

Z_i = h_g(a_i) + ε_i  
ε_i ~ N(0, σ_g^2)

Где:
- R^{use}_{c,g}(j) — трассово-годовой эталон на ln-шкале
- h_g(a) — возрастная поправка (сплайн), общая по всем трассам данного пола
- σ_g^2 — дисперсия остатка

Прогноз:
- Y_pred = ln R^{use}_{c,g}(j*) + h_g(a_new)
- T_pred = exp(Y_pred)
- интервалы и неопределённость строятся на Y-шкале, затем переводятся в секунды

---

## Поток данных

### 1. Загрузка данных (DataLoader)
- читает Excel
- приводит к единому контракту
- кэширует parquet

Выход:
- df_raw

---

### 2. Базовая фильтрация и валидация сырья
- filter_raw
- validate_raw
- add_row_id

Выход:
- df_raw_valid с индексом row_id

---

## 3. Предобработка (Preprocessor)

Цель: получить df_clean, где каждая строка — корректный старт, а идентификация людей детерминирована и воспроизводима.

### 3.1 Нормализация строк
- surname, name: trim, схлопывание пробелов, upper, пустые → NA (недопустимы)
- city: нормализация (канонизация)

### 3.2 Базовая идентификация человека по имени
- person_ordered_key = SURNAME|NAME
- person_set_key = min(SURNAME|NAME, NAME|SURNAME)
  (инвариант к перестановке имени и фамилии)

### 3.3 Приближённый год рождения
- approx_birth_year = year − age

### 3.4 Стабилизация года рождения
Внутри каждого person_set_key:
- строятся частоты approx_birth_year
- годы разбиваются на кластеры с шагом ≤ 1 год (цепочкой)
- для каждого кластера выбирается birth_year_stable
- строкам примерживается:
  - cluster_id
  - birth_year_stable

### 3.5 Формирование runner_id (контракт)
runner_id — строковый идентификатор гипотезы “один физический человек”.

Формат:
- runner_id = f"{person_set_key}_{birth_year_stable}_C{cluster_id}"

Если birth_year_stable или cluster_id отсутствуют:
- runner_id = f"{person_set_key}_UNKNOWN"

Этот формат является частью контракта и используется во всех последующих шагах.

### 3.6 Разрешение конфликтов города (политика проекта)
Город используется как жёсткий дискриминатор после стабилизации года рождения.

Шаги:
- если внутри runner_id город однозначен → заполняем пропуски этим значением
- если внутри runner_id город конфликтует (>=2 разных city) → делим runner_id по city
  (то есть считаем, что разные города означают разных людей, если иначе не доказано)

Контракт после шага:
- внутри runner_id город либо однозначен, либо NA (если везде NA)

### 3.7 Исправление пола (контракт для модели)
Цель: обеспечить однозначность пола внутри runner_id.

Шаги:
- если внутри runner_id есть строгое большинство по gender → присваиваем этот gender всем строкам runner_id
- если строгого большинства нет → runner_id целиком удаляется

Контракт после шага:
- в df_clean внутри runner_id пол однозначен

### 3.8 Удаление неразрешимых конфликтов “один старт”
Ситуация:
- у одного runner_id более одной строки в одном и том же (race_id, year)

Политика:
- если конфликт можно разрешить детерминированно (например, через разбиение по city) — решаем
- иначе удаляем такие строки/группы (шум, который мешает обучению и дальнейшей склейке стартов)

### 3.9 Строгая дедупликация
Удаляются точные дубликаты по ключу:
- (runner_id, race_id, year, time_seconds, bib_number)

### 3.10 Добавление модельных признаков
- Y = ln(time_seconds)
- x = (age − age_center) / age_scale

Выход:
- df_clean — финальный датасет для моделирования

---

## 4. Трассово-годовые эталоны R^{use}

### ReferenceBuilder

Важно: все операции top/trim/median определены на ln-шкале.

Протокол для каждой группы (race_id, gender, year) или (race_id, gender) с годовой поправкой (по текущему дизайну):
1) строим Y = ln(time_seconds)
2) ранжирование / top (если используется) делаем по Y
3) median берём по Y
4) эталон хранится как ln R^{use} (то есть в единицах Y)

Примечание:
- если trim уже исключён из проекта, то в коде и в этой карте trim не упоминается
- если top_fraction используется, он применяется на Y, а не на time_seconds

Выход:
- таблица эталонов ln R^{use}_{c,g}(j)

---

## 5. Возрастная модель (ключевая часть)

### fit_age_model

Вход:
- df_clean
- исключён validation_year (если задан)
- status == OK

Подготовка:
- вычисляем Z = Y − ln R^{use}_{c,g}(j) для каждой строки

Оценка:
- отдельно по каждому полу g
- оцениваем h_g(a) как сглаженную функцию (сплайн)
- оцениваем σ_g^2

Выход:
- параметры сплайна h_g
- оценка σ_g^2

---

## 6. Прогноз

Вход:
- race_id (⇔ c)
- gender (g)
- age (a)
- year (j*)

Шаги:
1) берём ln R^{use}_{c,g}(j*)
2) вычисляем h_g(a)
3) Y_pred = ln R^{use} + h_g(a)
4) переводим в секунды: T_pred = exp(Y_pred)
5) интервалы: считаем на Y-шкале с учётом σ_g^2, затем exp(·)

---

## 7. Валидация

На validation_year:
- ошибки на Y-шкале и на шкале секунд
- анализ по трассам и полу
- проверка покрытия интервалов (если интервалы реализованы)

---

## Что уже реализовано

- полный пайплайн предобработки до df_clean
- person_set_key, approx_birth_year
- кластеризация годов рождения внутри person_set_key и birth_year_stable
- runner_id в фиксированном формате
- нормализация/заполнение города и разбиение runner_id по конфликтному city
- исправление пола по большинству (или удаление при отсутствии большинства) [если добавлено в код]
- удаление неразрешимых мульти-стартов (один runner_id, один race_id, один year, >1 строк)
- построение трассовых эталонов
- инфраструктура/каркас fit_age_model с диагностикой

---

## Что осталось реализовать

1) Реальная оценка сплайна h_g(a)
2) Хранение параметров сплайна и применение на новых данных
3) Прогноз с неопределённостью (интервалы)
4) Блок валидации (метрики, отчёты)
5) Финальные дампы/отчёты для контроля качества данных и модели

---

## Принципиальные позиции проекта

- идентификация людей: только детерминированные правила, без “умных” кластеризаций
- возраст: только гладкая функция (сплайн), а не дискретные “возрастные эталоны”
- допускается удаление строк и целых runner_id при неразрешимых конфликтах
  (это сознательная политика качества данных, а не “ошибка пайплайна”)
